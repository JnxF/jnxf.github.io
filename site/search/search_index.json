{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Models are the cornerstone of knowledge in MDSE. Their understanding is, therefore, indispensable in the process. However, models and metamodels can grow in number of components and thus become difficult to comprehend and evolve. To solve that, we have devise a set of visualization patterns to facilitate the exploration and comprehension of models. Definition A visualization pattern requires: A source : it can be a metamodel, a model, or both (in which case the model must conform to the metamodel). A context : it describes the logic of the visualization technique. A binding : a 1-to-1 mapping from each class, attribute and reference in the concept to a class, attribute and reference in the meta-model, respectively. It needs to fulfil some well-formedness rules to ensure a correct application of the generic operation. [RAML13] When the binding is applied from the context to the source, an interaction emerges. This is the goal of the visualization pattern. As a result, there are changes in the UI, in the source, or in both. Variability The resulting interactions from visualization patterns lead to variability within the patterns. For instances, patterns can preserve all the elements of the source, or some may be filtered out. In that case, a heuristic function can be defined and applied. Moreover, patterns can modify the visual feature of the concepts or not. The following feature model explains the variability found in visualization patterns. Every pattern must conform to a valid configuration of it. Description Patterns are described with the following sections: Names. Patterns may have different names. Motivation. There are properties of models that justify the existence of a visualization pattern. Applicability. Patterns are not ubiquitously applicable. Sometimes there are constraints. Context. As described before. Participants. Each element of the context plays a different role in the pattern. Consequences. Interaction. The result, both on the models and on the UI, of the pattern. Example. Patterns are exemplified using toy models. Similar patterns. Variations. Variability lead to similar configurations of patterns. References. References [RAML13] Lara, J. de, Guerra, E., & Cuadrado, J. S. (2013, June 19). Reusable abstractions for modeling languages Information Systems. Retrieved February 19, 2022, from https://www.sciencedirect.com/science/article/pii/S030643791300080X .","title":"Introduction"},{"location":"#introduction","text":"Models are the cornerstone of knowledge in MDSE. Their understanding is, therefore, indispensable in the process. However, models and metamodels can grow in number of components and thus become difficult to comprehend and evolve. To solve that, we have devise a set of visualization patterns to facilitate the exploration and comprehension of models.","title":"Introduction"},{"location":"#definition","text":"A visualization pattern requires: A source : it can be a metamodel, a model, or both (in which case the model must conform to the metamodel). A context : it describes the logic of the visualization technique. A binding : a 1-to-1 mapping from each class, attribute and reference in the concept to a class, attribute and reference in the meta-model, respectively. It needs to fulfil some well-formedness rules to ensure a correct application of the generic operation. [RAML13] When the binding is applied from the context to the source, an interaction emerges. This is the goal of the visualization pattern. As a result, there are changes in the UI, in the source, or in both.","title":"Definition"},{"location":"#variability","text":"The resulting interactions from visualization patterns lead to variability within the patterns. For instances, patterns can preserve all the elements of the source, or some may be filtered out. In that case, a heuristic function can be defined and applied. Moreover, patterns can modify the visual feature of the concepts or not. The following feature model explains the variability found in visualization patterns. Every pattern must conform to a valid configuration of it.","title":"Variability"},{"location":"#description","text":"Patterns are described with the following sections: Names. Patterns may have different names. Motivation. There are properties of models that justify the existence of a visualization pattern. Applicability. Patterns are not ubiquitously applicable. Sometimes there are constraints. Context. As described before. Participants. Each element of the context plays a different role in the pattern. Consequences. Interaction. The result, both on the models and on the UI, of the pattern. Example. Patterns are exemplified using toy models. Similar patterns. Variations. Variability lead to similar configurations of patterns. References.","title":"Description"},{"location":"#references","text":"[RAML13] Lara, J. de, Guerra, E., & Cuadrado, J. S. (2013, June 19). Reusable abstractions for modeling languages Information Systems. Retrieved February 19, 2022, from https://www.sciencedirect.com/science/article/pii/S030643791300080X .","title":"References"},{"location":"techniques/drill-down/","text":"Drill down Names Drill down; roll up. Motivation Visualise the semantic value that compositions have. Traversing a composition to the composite elements increases the granularity of the visualisation. Applicability Whenever a composition relation exists between two concepts. Context classDiagram direction LR Container *-- Containee : containment Participants Container . The class that owns the composition. Containee . The class that is owned. containment . The composition relation. Optionally, a heuristic function h can be defined at the Container class to guide the representation of the Containee instances. Consequences Containee s are hidden until Container is asked to perform a drill down. Interaction Every time a Container is asked to perform a drill down, the Containee s through the containment reference are shown. To account for an increased granularity, the chosen Container element can be stacked into a breadcrumb. Example To exemplify drill down, we use a metamodel of the Earth. Planets contain countries, which, in turn, contain cities. classDiagram direction LR Planet *--> Country : countries Country *--> City : cities class Planet { name: string } class Country { name: string area: float h1() : float } class City { name: string population: int h2() : float } Drill down can be exploited in both the containments countries and cities . Two different heuristics are applied to reduce the number of displayed elements: In the countries relation, the area of the country is used as heuristic: \\(h_1(\\texttt{co}) = \\texttt{co.area}\\) . On the other hand, the cities relation uses the population of the city as heuristic: \\(h_2(\\texttt{ci}) = \\texttt{ci.population}\\) . Similar patterns TODO Variations TODO References","title":"Drill down"},{"location":"techniques/drill-down/#drill-down","text":"","title":"Drill down"},{"location":"techniques/drill-down/#names","text":"Drill down; roll up.","title":"Names"},{"location":"techniques/drill-down/#motivation","text":"Visualise the semantic value that compositions have. Traversing a composition to the composite elements increases the granularity of the visualisation.","title":"Motivation"},{"location":"techniques/drill-down/#applicability","text":"Whenever a composition relation exists between two concepts.","title":"Applicability"},{"location":"techniques/drill-down/#context","text":"classDiagram direction LR Container *-- Containee : containment","title":"Context"},{"location":"techniques/drill-down/#participants","text":"Container . The class that owns the composition. Containee . The class that is owned. containment . The composition relation. Optionally, a heuristic function h can be defined at the Container class to guide the representation of the Containee instances.","title":"Participants"},{"location":"techniques/drill-down/#consequences","text":"Containee s are hidden until Container is asked to perform a drill down.","title":"Consequences"},{"location":"techniques/drill-down/#interaction","text":"Every time a Container is asked to perform a drill down, the Containee s through the containment reference are shown. To account for an increased granularity, the chosen Container element can be stacked into a breadcrumb.","title":"Interaction"},{"location":"techniques/drill-down/#example","text":"To exemplify drill down, we use a metamodel of the Earth. Planets contain countries, which, in turn, contain cities. classDiagram direction LR Planet *--> Country : countries Country *--> City : cities class Planet { name: string } class Country { name: string area: float h1() : float } class City { name: string population: int h2() : float } Drill down can be exploited in both the containments countries and cities . Two different heuristics are applied to reduce the number of displayed elements: In the countries relation, the area of the country is used as heuristic: \\(h_1(\\texttt{co}) = \\texttt{co.area}\\) . On the other hand, the cities relation uses the population of the city as heuristic: \\(h_2(\\texttt{ci}) = \\texttt{ci.population}\\) .","title":"Example"},{"location":"techniques/drill-down/#similar-patterns","text":"TODO","title":"Similar patterns"},{"location":"techniques/drill-down/#variations","text":"TODO","title":"Variations"},{"location":"techniques/drill-down/#references","text":"","title":"References"},{"location":"techniques/dynamic-filter/","text":"Dynamic filter Names Dynamic filter, deletion. Motivation Showing only a subset of classes and relations of a model can facilitate its exploration and comprehension. Applicability Filters can be applied to any model. Context The context is a replica of the metamodel with the subset of classes and relations chosen by the user. Participants Two components: The classes that are selected. The relations that are selected. The catalog of relations available depends on the selected classes. That is why the filter is dynamic . Consequences Only the selected classes and relations are shown. Interaction Two panels are displayed to the user: Classes and Relations . The first includes a checkbox per each metaclass at scope of the model; the latter does the same with the relations of the selected classes. Relations partaking non-selected classes can be hidden or shown as disabled. The model is filtered according to the selection; only selected classes and relations are shown. Example A university metamodel defines three metaclasses: University , Professor and Student . A university hasStudent s and hires professors. A professor teaches some students. A student knows other students. classDiagram direction LR University --> \"*\" Professor : hires Professor --> \"*\" Student : teaches University --> \"*\" Student : hasStudent Student --> \"*\" Student : knows To apply the pattern, the UI introduces checkboxes for the three metaclasses and all their relations. Relations are only available if their sources and targets are to be displayed. In this case, only Professor s, Student s and their teaches relations are shown. The image that follows shows the result of applying this filter to an example model. Similar patterns This pattern is called deletion on [RAML13]. Variations References [RAML13]","title":"Dynamic filter"},{"location":"techniques/dynamic-filter/#dynamic-filter","text":"","title":"Dynamic filter"},{"location":"techniques/dynamic-filter/#names","text":"Dynamic filter, deletion.","title":"Names"},{"location":"techniques/dynamic-filter/#motivation","text":"Showing only a subset of classes and relations of a model can facilitate its exploration and comprehension.","title":"Motivation"},{"location":"techniques/dynamic-filter/#applicability","text":"Filters can be applied to any model.","title":"Applicability"},{"location":"techniques/dynamic-filter/#context","text":"The context is a replica of the metamodel with the subset of classes and relations chosen by the user.","title":"Context"},{"location":"techniques/dynamic-filter/#participants","text":"Two components: The classes that are selected. The relations that are selected. The catalog of relations available depends on the selected classes. That is why the filter is dynamic .","title":"Participants"},{"location":"techniques/dynamic-filter/#consequences","text":"Only the selected classes and relations are shown.","title":"Consequences"},{"location":"techniques/dynamic-filter/#interaction","text":"Two panels are displayed to the user: Classes and Relations . The first includes a checkbox per each metaclass at scope of the model; the latter does the same with the relations of the selected classes. Relations partaking non-selected classes can be hidden or shown as disabled. The model is filtered according to the selection; only selected classes and relations are shown.","title":"Interaction"},{"location":"techniques/dynamic-filter/#example","text":"A university metamodel defines three metaclasses: University , Professor and Student . A university hasStudent s and hires professors. A professor teaches some students. A student knows other students. classDiagram direction LR University --> \"*\" Professor : hires Professor --> \"*\" Student : teaches University --> \"*\" Student : hasStudent Student --> \"*\" Student : knows To apply the pattern, the UI introduces checkboxes for the three metaclasses and all their relations. Relations are only available if their sources and targets are to be displayed. In this case, only Professor s, Student s and their teaches relations are shown. The image that follows shows the result of applying this filter to an example model.","title":"Example"},{"location":"techniques/dynamic-filter/#similar-patterns","text":"This pattern is called deletion on [RAML13].","title":"Similar patterns"},{"location":"techniques/dynamic-filter/#variations","text":"","title":"Variations"},{"location":"techniques/dynamic-filter/#references","text":"[RAML13]","title":"References"},{"location":"techniques/heuristic-visualization/","text":"Heuristic visualization Names Heuristic visualization. Motivation The local context of a concept (i.e. its attributes values and its relations) can be used to guide the user in the exploration of a model. Heuristics can be extracted from concepts, that then can be visualized using visual features. Applicability Heuristic visualization can be applied to any model. Context The context is a single target metaclass, Target with a heuristic function, h . classDiagram direction LR class Target { h() : float } Participants Target . The targeted metaclass. \\(h\\) , the heuristic. It is a numeric function defined in Target and, as such, is enclosed within the local context of Target , namely \\(LC\\) . Therefore, \\(h\\colon LC \\to \\mathbb R\\) is its signature. Its value is significative to the desired visualization. An ancillary function \\(\\textit{visualMap} : \\mathbb R \\to VF\\) , where \\(VF\\) is the visual feature space of a concept. The composition of both functions yields \\(f = \\textit{visualMap} \\circ h\\) , a \\(LC \\to VF\\) function. That is, a function that maps local contexts of Target instances to visual features. Consequences \u2014 Interaction A heuristic function \\(h\\) is defined at a Target metaclass depending on the desired visualization. Then, the visual features of the Target instances are decided on the evaluation of \\(f\\) . Example A university metamodel defines three metaclasses: University , Professor and Student . A university hasStudent s and hires professors. A professor teaches some students. A student knows other students. classDiagram direction LR University --> \"*\" Professor : hires Professor --> \"*\" Student : teaches University --> \"*\" Student : hasStudent Student --> \"*\" Student : knows class Professor { h() : float } In this case, we are interested in visualizing which professors teach the most. To apply the pattern, Professor:: \\(h\\) is defined as the number of students that a professor teaches. context Professor :: h () : float = self . teaches . size () Then \\(\\textit{visualMap}\\) is defined to map the received value \\(n\\) to a visual features object whose value for the size and the border are both \\(n\\) . That is, these visual features scale linearly \\(n\\) . Other visual features can be left unaltered, such as the background color or the font size. \\[ visualMap(n) = \\left\\{\\begin{array}{ll} \\textrm{size:} & n\\\\ \\textrm{borderWidth:} & n\\\\ \\end{array}\\right\\} \\] At the end, the result of the pattern is the application of \\(f = \\textit{visualMap} \\circ h\\) , which becomes: \\[ f(\\texttt{lc}) = \\left\\{\\begin{array}{ll} \\textrm{size:} & \\texttt{lc.teaches.size()}\\\\ \\textrm{borderWidth:} & \\texttt{lc.teaches.size()}\\\\ \\end{array}\\right\\} \\] Similar patterns TODO Variations TODO References TODO","title":"Heuristic visualization"},{"location":"techniques/heuristic-visualization/#heuristic-visualization","text":"","title":"Heuristic visualization"},{"location":"techniques/heuristic-visualization/#names","text":"Heuristic visualization.","title":"Names"},{"location":"techniques/heuristic-visualization/#motivation","text":"The local context of a concept (i.e. its attributes values and its relations) can be used to guide the user in the exploration of a model. Heuristics can be extracted from concepts, that then can be visualized using visual features.","title":"Motivation"},{"location":"techniques/heuristic-visualization/#applicability","text":"Heuristic visualization can be applied to any model.","title":"Applicability"},{"location":"techniques/heuristic-visualization/#context","text":"The context is a single target metaclass, Target with a heuristic function, h . classDiagram direction LR class Target { h() : float }","title":"Context"},{"location":"techniques/heuristic-visualization/#participants","text":"Target . The targeted metaclass. \\(h\\) , the heuristic. It is a numeric function defined in Target and, as such, is enclosed within the local context of Target , namely \\(LC\\) . Therefore, \\(h\\colon LC \\to \\mathbb R\\) is its signature. Its value is significative to the desired visualization. An ancillary function \\(\\textit{visualMap} : \\mathbb R \\to VF\\) , where \\(VF\\) is the visual feature space of a concept. The composition of both functions yields \\(f = \\textit{visualMap} \\circ h\\) , a \\(LC \\to VF\\) function. That is, a function that maps local contexts of Target instances to visual features.","title":"Participants"},{"location":"techniques/heuristic-visualization/#consequences","text":"\u2014","title":"Consequences"},{"location":"techniques/heuristic-visualization/#interaction","text":"A heuristic function \\(h\\) is defined at a Target metaclass depending on the desired visualization. Then, the visual features of the Target instances are decided on the evaluation of \\(f\\) .","title":"Interaction"},{"location":"techniques/heuristic-visualization/#example","text":"A university metamodel defines three metaclasses: University , Professor and Student . A university hasStudent s and hires professors. A professor teaches some students. A student knows other students. classDiagram direction LR University --> \"*\" Professor : hires Professor --> \"*\" Student : teaches University --> \"*\" Student : hasStudent Student --> \"*\" Student : knows class Professor { h() : float } In this case, we are interested in visualizing which professors teach the most. To apply the pattern, Professor:: \\(h\\) is defined as the number of students that a professor teaches. context Professor :: h () : float = self . teaches . size () Then \\(\\textit{visualMap}\\) is defined to map the received value \\(n\\) to a visual features object whose value for the size and the border are both \\(n\\) . That is, these visual features scale linearly \\(n\\) . Other visual features can be left unaltered, such as the background color or the font size. \\[ visualMap(n) = \\left\\{\\begin{array}{ll} \\textrm{size:} & n\\\\ \\textrm{borderWidth:} & n\\\\ \\end{array}\\right\\} \\] At the end, the result of the pattern is the application of \\(f = \\textit{visualMap} \\circ h\\) , which becomes: \\[ f(\\texttt{lc}) = \\left\\{\\begin{array}{ll} \\textrm{size:} & \\texttt{lc.teaches.size()}\\\\ \\textrm{borderWidth:} & \\texttt{lc.teaches.size()}\\\\ \\end{array}\\right\\} \\]","title":"Example"},{"location":"techniques/heuristic-visualization/#similar-patterns","text":"TODO","title":"Similar patterns"},{"location":"techniques/heuristic-visualization/#variations","text":"TODO","title":"Variations"},{"location":"techniques/heuristic-visualization/#references","text":"TODO","title":"References"},{"location":"techniques/incidence-heatmap/","text":"Incidence heatmap Names Incidence heatmap Motivation Metamodels employ associativity in varying degrees of specificity: from regular associations to aggregations and compositions. The more specific the relationships between to metaclasses are, the more coupled they are. This coupling can be visualized using a heatmap. Applicability Any metamodel. Context The entire metamodel. Participants Each metaclass. The associations (including aggregations and compositions) of every metaclass. Consequences TODO Interaction The associations between metaclasses yield a heatmap where the intensity is determined by the maximum level of coupling between any two given metaclasses. Given \\(n\\) metaclasses, the heatmap is the \\(n \\times n\\) matrix \\(\\mathcal M\\) , where the value of an entry is: \\[ M_{ij} = \\left\\{ \\begin{array}{ll} 0, & \\text{if } \\sum_k a_k (i\\to j ) = 0 \\\\ \\textrm{argmax}_k \\{k \\mid a_k (i \\to j) \\geq 1\\}, & \\text {otherwise} \\end{array} \\right. \\] where \\(a_1\\) , \\(a_2\\) , \\(a_3\\) are functions that count the number of associations, aggregations and compositions, respectively, between metaclasses \\(i\\) and \\(j\\) . The values of each entry can be visualized using a color/heat schema. Example The incidence hetamap is exemplified using the following library metamodel (extended from [CNN]). classDiagram direction LR Library *--> \"*\" Book : books Library --> \"*\" Member : members Library o--> \"*\" Writer : writers Writer --> \"*\" Book : books Writer --|> Person Book --> \"*\" Writer : authors Member --|> Person class Library { name : String } class Book { title : String pages : Int = 100 } class Person { firstName : String lastName : String } class Writer { } class Member { } The heatmap reflects the coupling between the metaclasses: Similar patterns TODO Variations TODO References [CNN] Nguyen, Phuong & Di Ruscio, Davide & Pierantonio, Alfonso & Rocco, Juri & Iovino, Ludovico. (2020). Convolutional neural networks for enhanced classification mechanisms of metamodels. Journal of Systems and Software. 172. 110860. 10.1016/j.jss.2020.110860.","title":"Incidence heatmap"},{"location":"techniques/incidence-heatmap/#incidence-heatmap","text":"","title":"Incidence heatmap"},{"location":"techniques/incidence-heatmap/#names","text":"Incidence heatmap","title":"Names"},{"location":"techniques/incidence-heatmap/#motivation","text":"Metamodels employ associativity in varying degrees of specificity: from regular associations to aggregations and compositions. The more specific the relationships between to metaclasses are, the more coupled they are. This coupling can be visualized using a heatmap.","title":"Motivation"},{"location":"techniques/incidence-heatmap/#applicability","text":"Any metamodel.","title":"Applicability"},{"location":"techniques/incidence-heatmap/#context","text":"The entire metamodel.","title":"Context"},{"location":"techniques/incidence-heatmap/#participants","text":"Each metaclass. The associations (including aggregations and compositions) of every metaclass.","title":"Participants"},{"location":"techniques/incidence-heatmap/#consequences","text":"TODO","title":"Consequences"},{"location":"techniques/incidence-heatmap/#interaction","text":"The associations between metaclasses yield a heatmap where the intensity is determined by the maximum level of coupling between any two given metaclasses. Given \\(n\\) metaclasses, the heatmap is the \\(n \\times n\\) matrix \\(\\mathcal M\\) , where the value of an entry is: \\[ M_{ij} = \\left\\{ \\begin{array}{ll} 0, & \\text{if } \\sum_k a_k (i\\to j ) = 0 \\\\ \\textrm{argmax}_k \\{k \\mid a_k (i \\to j) \\geq 1\\}, & \\text {otherwise} \\end{array} \\right. \\] where \\(a_1\\) , \\(a_2\\) , \\(a_3\\) are functions that count the number of associations, aggregations and compositions, respectively, between metaclasses \\(i\\) and \\(j\\) . The values of each entry can be visualized using a color/heat schema.","title":"Interaction"},{"location":"techniques/incidence-heatmap/#example","text":"The incidence hetamap is exemplified using the following library metamodel (extended from [CNN]). classDiagram direction LR Library *--> \"*\" Book : books Library --> \"*\" Member : members Library o--> \"*\" Writer : writers Writer --> \"*\" Book : books Writer --|> Person Book --> \"*\" Writer : authors Member --|> Person class Library { name : String } class Book { title : String pages : Int = 100 } class Person { firstName : String lastName : String } class Writer { } class Member { } The heatmap reflects the coupling between the metaclasses:","title":"Example"},{"location":"techniques/incidence-heatmap/#similar-patterns","text":"TODO","title":"Similar patterns"},{"location":"techniques/incidence-heatmap/#variations","text":"TODO","title":"Variations"},{"location":"techniques/incidence-heatmap/#references","text":"[CNN] Nguyen, Phuong & Di Ruscio, Davide & Pierantonio, Alfonso & Rocco, Juri & Iovino, Ludovico. (2020). Convolutional neural networks for enhanced classification mechanisms of metamodels. Journal of Systems and Software. 172. 110860. 10.1016/j.jss.2020.110860.","title":"References"},{"location":"techniques/inheritance-exploration/","text":"Inheritance exploration","title":"Inheritance exploration"},{"location":"techniques/inheritance-exploration/#inheritance-exploration","text":"","title":"Inheritance exploration"},{"location":"techniques/layer-exploration/","text":"Layer exploration Names Layer exploration, breadth-first exploration. Motivation Objects within a closer distance to an initial object are more likely to provide semantic information. A layer-based exploration exploits this heuristic. Applicability Any model. Larger models can yield better results. Context A Target class, and all the relations R1 , \u2026, Rn from Target to them, recursively. Participants Target , the class whose objects are to be explored. All the relations R1 , \u2026, Rn that emerge from Target . These relations will lead to other relations, namely, R11 , R12 from R1 ; R21 , R22 from R2 , and so on. The process follows recursively as much as possible. Consequences The recursivity on the relations leads to a layer-based (or breadth-first) exploration. Given an initial object \\(s\\) , layers can be defined as follows: \\[ l^n = \\left\\{ \\begin{array}{ll} \\{s\\}& \\text{for } n = 0\\\\ \\bigcup_i \\mathcal R(l^{n-1}_i) - \\bigcup_{m=0}^{m-2}(l^m) & \\text{for $n \\geq 1,$} \\end{array} \\right. \\] where \\(n\\) is the layer number and \\(\\mathcal R(o)\\) is the set of objects that are reachable from an object \\(o\\) through any of its relations \\(R_1, \\dots, R_n\\) . Mathematically: \\[\\mathcal R(o) = \\{ r \\mid \\exists R_i \\land r \\in R_i\\}.\\] Informally, a layer is either the object to be explored, \\(s\\) , or the set of objects that are reachable from the immediately previous layer, without repeating any object (that is why \\(l^{n-2},\\; l^{n-3},\\; \\dots\\) are always subtracted from the resulting layer). Interaction Layers \\(l^0,\\; l^1,\\; \\dots,\\; l^n\\) , that emerge from \\(s\\) can be displayed distinctly and progressively. Example To exemplify layer exploration, we use a metamodel of the Earth. Planets contain countries, which, in turn, contain cities. classDiagram direction LR Planet *--> Country : countries Country *--> City : cities class Planet { name: string } class Country { name: string area: float h1() : float } class City { name: string population: int h2() : float } TODO: finish Similar patterns Drill down Variations TODO References TODO","title":"Layer exploration"},{"location":"techniques/layer-exploration/#layer-exploration","text":"","title":"Layer exploration"},{"location":"techniques/layer-exploration/#names","text":"Layer exploration, breadth-first exploration.","title":"Names"},{"location":"techniques/layer-exploration/#motivation","text":"Objects within a closer distance to an initial object are more likely to provide semantic information. A layer-based exploration exploits this heuristic.","title":"Motivation"},{"location":"techniques/layer-exploration/#applicability","text":"Any model. Larger models can yield better results.","title":"Applicability"},{"location":"techniques/layer-exploration/#context","text":"A Target class, and all the relations R1 , \u2026, Rn from Target to them, recursively.","title":"Context"},{"location":"techniques/layer-exploration/#participants","text":"Target , the class whose objects are to be explored. All the relations R1 , \u2026, Rn that emerge from Target . These relations will lead to other relations, namely, R11 , R12 from R1 ; R21 , R22 from R2 , and so on. The process follows recursively as much as possible.","title":"Participants"},{"location":"techniques/layer-exploration/#consequences","text":"The recursivity on the relations leads to a layer-based (or breadth-first) exploration. Given an initial object \\(s\\) , layers can be defined as follows: \\[ l^n = \\left\\{ \\begin{array}{ll} \\{s\\}& \\text{for } n = 0\\\\ \\bigcup_i \\mathcal R(l^{n-1}_i) - \\bigcup_{m=0}^{m-2}(l^m) & \\text{for $n \\geq 1,$} \\end{array} \\right. \\] where \\(n\\) is the layer number and \\(\\mathcal R(o)\\) is the set of objects that are reachable from an object \\(o\\) through any of its relations \\(R_1, \\dots, R_n\\) . Mathematically: \\[\\mathcal R(o) = \\{ r \\mid \\exists R_i \\land r \\in R_i\\}.\\] Informally, a layer is either the object to be explored, \\(s\\) , or the set of objects that are reachable from the immediately previous layer, without repeating any object (that is why \\(l^{n-2},\\; l^{n-3},\\; \\dots\\) are always subtracted from the resulting layer).","title":"Consequences"},{"location":"techniques/layer-exploration/#interaction","text":"Layers \\(l^0,\\; l^1,\\; \\dots,\\; l^n\\) , that emerge from \\(s\\) can be displayed distinctly and progressively.","title":"Interaction"},{"location":"techniques/layer-exploration/#example","text":"To exemplify layer exploration, we use a metamodel of the Earth. Planets contain countries, which, in turn, contain cities. classDiagram direction LR Planet *--> Country : countries Country *--> City : cities class Planet { name: string } class Country { name: string area: float h1() : float } class City { name: string population: int h2() : float } TODO: finish","title":"Example"},{"location":"techniques/layer-exploration/#similar-patterns","text":"Drill down","title":"Similar patterns"},{"location":"techniques/layer-exploration/#variations","text":"TODO","title":"Variations"},{"location":"techniques/layer-exploration/#references","text":"TODO","title":"References"}]}